#include "precompute_jacobian.hpp"
#include <cstdint>
#include <xtensor/xio.hpp>
#include <xtensor/xindex_view.hpp>

namespace {
    template <typename T>
    inline void skernel(T* A, const T* w, const T* c, const double* detJ, const xt::xtensor<double, 3>& J, const xt::xtensor<double, 3>& phi, int nq, int nd){
        // Quadrature rules
    static const double weights_405[16] = { 0.006944444444444428, 0.006944444444444438, 0.03472222222222217, 0.03472222222222215, 0.006944444444444438, 0.006944444444444448, 0.03472222222222222, 0.0347222222222222, 0.03472222222222217, 0.03472222222222222, 0.173611111111111, 0.1736111111111109, 0.03472222222222215, 0.0347222222222222, 0.1736111111111109, 0.1736111111111109 };
    static const double FE8_C0_D01_Q405[1][1][16][16] =
        { { { { -6.000000000000007, 0.0, 1.0, 0.0, 0.0, 0.0, 8.090169943749483, -3.090169943749481, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { -1.0, 0.0, 6.000000000000003, 0.0, 0.0, 0.0, 3.090169943749475, -8.090169943749476, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { -1.618033988749896, 0.0, -0.618033988749895, 0.0, 0.0, 0.0, 0.0, 2.236067977499791, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.6180339887498951, 0.0, 1.618033988749896, 0.0, 0.0, 0.0, -2.236067977499791, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, -6.000000000000004, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 8.09016994374948, -3.090169943749478, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, -1.0, 0.0, 5.999999999999998, 0.0, 0.0, 0.0, 0.0, 3.090169943749477, -8.090169943749473, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, -1.618033988749894, 0.0, -0.6180339887498945, 0.0, 0.0, 0.0, 0.0, 0.0, 2.236067977499789, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.6180339887498945, 0.0, 1.618033988749894, 0.0, 0.0, 0.0, 0.0, -2.23606797749979, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, -6.000000000000004, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 8.09016994374948, 0.0, -3.09016994374948, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.999999999999998, 0.0, 3.090169943749474, 0.0, -8.090169943749476, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, -1.618033988749894, 0.0, 0.0, 0.0, 0.0, 0.0, -0.6180339887498942, 0.0, 0.0, 0.0, 2.23606797749979, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.6180339887498948, 0.0, 0.0, 0.0, 0.0, 0.0, 1.618033988749895, 0.0, -2.23606797749979, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, -6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 8.090169943749482, 0.0, -3.090169943749479 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.999999999999999, 0.0, 3.090169943749476, 0.0, -8.090169943749473 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, -1.618033988749894, 0.0, 0.0, 0.0, 0.0, 0.0, -0.6180339887498946, 0.0, 0.0, 0.0, 2.23606797749979 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.6180339887498942, 0.0, 0.0, 0.0, 0.0, 0.0, 1.618033988749894, 0.0, -2.236067977499789, 0.0, 0.0 } } } };
    static const double FE8_C0_D10_Q405[1][1][16][16] =
        { { { { -6.000000000000006, 1.0, 0.0, 0.0, 8.090169943749483, -3.09016994374948, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, -6.000000000000003, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 8.090169943749478, -3.090169943749477, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -6.000000000000002, 0.0, 1.0, 0.0, 0.0, 0.0, 8.09016994374948, -3.09016994374948, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -6.000000000000001, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 8.09016994374948, -3.090169943749479 },
              { -1.0, 6.000000000000004, 0.0, 0.0, 3.090169943749477, -8.090169943749476, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, -1.0, 5.999999999999998, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.090169943749477, -8.090169943749469, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 6.0, 0.0, 0.0, 0.0, 3.090169943749475, -8.090169943749475, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 5.999999999999998, 0.0, 0.0, 0.0, 0.0, 3.090169943749474, -8.090169943749473 },
              { -1.618033988749896, -0.6180339887498955, 0.0, 0.0, 0.0, 2.23606797749979, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, -1.618033988749895, -0.6180339887498947, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.236067977499789, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.618033988749895, 0.0, -0.6180339887498947, 0.0, 0.0, 0.0, 0.0, 2.236067977499789, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.618033988749895, 0.0, -0.6180339887498947, 0.0, 0.0, 0.0, 0.0, 0.0, 2.23606797749979 },
              { 0.6180339887498955, 1.618033988749896, 0.0, 0.0, -2.236067977499791, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, 0.6180339887498945, 1.618033988749895, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -2.236067977499789, 0.0, 0.0, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6180339887498948, 0.0, 1.618033988749895, 0.0, 0.0, 0.0, -2.236067977499789, 0.0, 0.0, 0.0 },
              { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6180339887498943, 0.0, 1.618033988749894, 0.0, 0.0, 0.0, 0.0, -2.23606797749979, 0.0 } } } };
    for (int iq = 0; iq < 16; ++iq)
    {
        // Quadrature loop body setup for quadrature rule 405
        // Varying computations for quadrature rule 405
        const double J_c0 = J(iq, 0, 0);
        const double J_c3 = J(iq, 1, 1);
        const double J_c1 = J(iq, 0, 1);
        const double J_c2 = J(iq, 1, 0);
        // std::cout << "J_c0 = " << J_c0 << std::endl;
        // std::cout << "J_c1 = " << J_c1 << std::endl;
        // std::cout << "J_c2 = " << J_c2 << std::endl;
        // std::cout << "J_c3 = " << J_c3 << std::endl;
        // std::cout << xt::view(phi, 0, xt::all(), xt::all()) << std::endl;
        // std::getchar();
        double w0_d01 = 0.0;
        double w0_d10 = 0.0;
        for (int ic = 0; ic < 16; ++ic)
        {
            // w0_d01 += w[ic] * FE8_C0_D01_Q405[0][0][iq][ic]; // phi(1, iq, ic); // dy
            // w0_d10 += w[ic] * FE8_C0_D10_Q405[0][0][iq][ic]; // phi(0, iq, ic); // dx
            w0_d01 += w[ic] * phi(1, iq, ic); // dy
            w0_d10 += w[ic] * phi(0, iq, ic); // dx
            // std::cout << w0_d01 << " " << w0_d10 << std::endl;
            // std::getchar();
        }
        double sv_405[24];
        sv_405[0] = J_c0 * J_c3;
        sv_405[1] = J_c1 * J_c2;
        sv_405[2] = sv_405[0] + -1 * sv_405[1];
        sv_405[3] = J_c0 / sv_405[2];
        sv_405[4] = (-1 * J_c1) / sv_405[2];
        sv_405[5] = w0_d01 * sv_405[3];
        sv_405[6] = w0_d10 * sv_405[4];
        sv_405[7] = sv_405[5] + sv_405[6];
        sv_405[8] = sv_405[7] * sv_405[3];
        sv_405[9] = sv_405[7] * sv_405[4];
        sv_405[10] = J_c3 / sv_405[2];
        sv_405[11] = (-1 * J_c2) / sv_405[2];
        sv_405[12] = w0_d10 * sv_405[10];
        sv_405[13] = w0_d01 * sv_405[11];
        sv_405[14] = sv_405[12] + sv_405[13];
        sv_405[15] = sv_405[14] * sv_405[11];
        sv_405[16] = sv_405[14] * sv_405[10];
        sv_405[17] = sv_405[8] + sv_405[15];
        sv_405[18] = sv_405[16] + sv_405[9];
        sv_405[19] = sv_405[17] * std::pow(c[0], 2);
        sv_405[20] = sv_405[18] * std::pow(c[0], 2);
        sv_405[21] = std::fabs(sv_405[2]);
        sv_405[22] = sv_405[19] * sv_405[21];
        sv_405[23] = sv_405[20] * sv_405[21];
        const double fw0 = sv_405[23] * weights_405[iq];
        const double fw1 = sv_405[22] * weights_405[iq];
        // std::cout << fw0 << " " << fw1 << std::endl;
        // std::getchar();
        for (int i = 0; i < 16; ++i){
            // A[i] += fw0 * FE8_C0_D10_Q405[0][0][iq][i] + fw1 * FE8_C0_D01_Q405[0][0][iq][i];
            A[i] += fw0 * phi(0, iq, i) + fw1 * phi(1, iq, i);
        }
    }
    }
        // const double weights_fdb[16] = { 0.006944444444444428, 0.006944444444444438, 0.03472222222222217, 0.03472222222222215, 0.006944444444444438, 0.006944444444444448, 0.03472222222222222, 0.0347222222222222, 0.03472222222222217, 0.03472222222222222, 0.173611111111111, 0.1736111111111109, 0.03472222222222215, 0.0347222222222222, 0.1736111111111109, 0.1736111111111109 };
        // for (int iq = 0; iq < nq; ++iq){
        //     double w0_d01 = 0.0;
        //     double w0_d10 = 0.0;
        //     for (int ic = 0; ic < nd; ++ic){
        //         w0_d01 += w[ic] * phi(1, iq, ic);
        //         w0_d10 += w[ic] * phi(0, iq, ic);
        //     }
        //     double sv_fdb[24];
        //     sv_fdb[0] = J(iq, 0, 0) * J(iq, 1, 1);
        //     sv_fdb[1] = J(iq, 0, 1) * J(iq, 1, 0);
        //     sv_fdb[2] = sv_fdb[0] + -1 * sv_fdb[1];
        //     sv_fdb[3] = J(iq, 0, 0) / sv_fdb[2];
        //     sv_fdb[4] = (-1 * J(iq, 0, 1)) / sv_fdb[2];
        //     sv_fdb[5] = w0_d01 * sv_fdb[3];
        //     sv_fdb[6] = w0_d10 * sv_fdb[4];
        //     sv_fdb[7] = sv_fdb[5] + sv_fdb[6];
        //     sv_fdb[8] = sv_fdb[7] * sv_fdb[3];
        //     sv_fdb[9] = sv_fdb[7] * sv_fdb[4];
        //     sv_fdb[10] = J(iq, 1, 1) / sv_fdb[2];
        //     sv_fdb[11] = (-1 * J(iq, 1, 0)) / sv_fdb[2];
        //     sv_fdb[12] = w0_d10 * sv_fdb[10];
        //     sv_fdb[13] = w0_d01 * sv_fdb[11];
        //     sv_fdb[14] = sv_fdb[12] + sv_fdb[13];
        //     sv_fdb[15] = sv_fdb[14] * sv_fdb[11];
        //     sv_fdb[16] = sv_fdb[14] * sv_fdb[10];
        //     sv_fdb[17] = sv_fdb[8] + sv_fdb[15];
        //     sv_fdb[18] = sv_fdb[16] + sv_fdb[9];
        //     sv_fdb[19] = (-1 * sv_fdb[17]) * pow(c[0], 2);
        //     sv_fdb[20] = (-1 * sv_fdb[18]) * pow(c[0], 2);
        //     sv_fdb[21] = fabs(sv_fdb[2]);
        //     sv_fdb[22] = sv_fdb[19] * sv_fdb[21];
        //     sv_fdb[23] = sv_fdb[20] * sv_fdb[21];
        //     const double fw0 = sv_fdb[23] * weights_fdb[iq];
        //     const double fw1 = sv_fdb[22] * weights_fdb[iq];
        //     for (int i = 0; i < nd; ++i)
        //         A[i] += fw0 * phi(0, iq, i) + fw1 * phi(1, iq, i);
        //     }
        // }
}

template <typename T>
class StiffnessOperator {
    private:
        std::vector<T> _x, _y;
        std::int32_t _ncells, _ndofs;
        graph::AdjacencyList<std::int32_t> _dofmap;
        xt::xtensor<double, 4> _J, _basis;
        xt::xtensor<double, 2> _detJ;
        xt::xtensor<double, 3> _phi;
        xt::xtensor<int, 1> _pidx;
    public:
        StiffnessOperator(std::shared_ptr<fem::FunctionSpace>& V, int P=3) : _dofmap(0) {
            std::shared_ptr<const mesh::Mesh> mesh = V->mesh();
            int tdim = mesh->topology().dim();
            _ncells = mesh->topology().index_map(tdim)->size_local();
            _ndofs = (P + 1)*(P + 1);
            _x.resize(_ndofs);
            _y.resize(_ndofs);

            std::pair<xt::xtensor<double, 4>, xt::xtensor<double, 2>> 
            p1 = precompute_jacobian(mesh, 4);
            _J = std::get<xt::xtensor<double, 4>>(p1);
            _detJ = std::get<xt::xtensor<double, 2>>(p1);

            std::pair<xt::xtensor<int, 1>, xt::xtensor<double, 4>> 
            p2 = tabulate_basis_and_permutation();
            _pidx = std::get<xt::xtensor<int, 1>>(p2);
            _basis = std::get<xt::xtensor<double, 4>>(p2);
            _phi = xt::view(_basis, xt::range(1, 3), xt::all(), xt::all(), 0);
            xt::filtration(_phi, xt::isclose(_phi, 0.0)) = 0;
            xt::filtration(_phi, xt::isclose(_phi, 1.0)) = 1;
            xt::filtration(_phi, xt::isclose(_phi, -1.0)) = -1;

            _dofmap = V->dofmap()->list();
        }

        template <typename Alloc>
        void operator()(const la::Vector<T, Alloc>& x, la::Vector<T, Alloc>& y){
            xtl::span<const T> x_array = x.array();
            xtl::span<T> y_array = y.mutable_array();
            int nq = _detJ.shape(1);
            tcb::span<const int> cell_dofs;
            xt::xtensor<double, 3> J;
            double* c = new double[1];
            c[0] = 1486.0;
            for (std::int32_t cell = 0; cell < _ncells; ++cell){
                cell_dofs = _dofmap.links(cell);
                for (int i = 0; i < _ndofs; i++){
                    _x[i] = x_array[cell_dofs[i]];
                }
                std::fill(_y.begin(), _y.end(), 0.0);
                double* detJ_ptr = _detJ.data() + cell * nq;
                J = xt::view(_J, cell, xt::all(), xt::all(), xt::all());
                skernel<double> (_y.data(), _x.data(), c, detJ_ptr, J, _phi, nq, _ndofs);
                for (int i = 0; i < _ndofs; i++){
                    y_array[cell_dofs[i]] += _y[i];
                }
            }
        }
};